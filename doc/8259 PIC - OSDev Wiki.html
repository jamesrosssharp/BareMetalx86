<!DOCTYPE html>
<html dir="ltr" class="client-js" lang="en"><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<title>8259 PIC - OSDev Wiki</title>
<meta charset="UTF-8">
<meta name="generator" content="MediaWiki 1.18.0">
<link rel="shortcut icon" href="http://wiki.osdev.org/favicon.ico">
<link rel="search" type="application/opensearchdescription+xml" href="http://wiki.osdev.org/opensearch_desc.php" title="OSDev Wiki (en)">
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.osdev.org/api.php?action=rsd">
<link rel="alternate" type="application/atom+xml" title="OSDev Wiki Atom feed" href="http://wiki.osdev.org/index.php?title=Special:RecentChanges&amp;feed=atom">
<link rel="stylesheet" href="8259%20PIC%20-%20OSDev%20Wiki_files/load.css">
<style type="text/css" media="all">.mw-collapsible-toggle{float:right} li .mw-collapsible-toggle{float:none} .mw-collapsible-toggle-li{list-style:none}

/* cache key: wikidb:resourceloader:filter:minify-css:4:4250852ed2349a0d4d0fc6509a3e7d4c */
</style><style type="text/css" media="all">.js-messagebox{margin:1em 5%;padding:0.5em 2.5%;border:1px solid #ccc;background-color:#fcfcfc;font-size:0.8em}.js-messagebox .js-messagebox-group{margin:1px;padding:0.5em 2.5%;border-bottom:1px solid #ddd}.js-messagebox .js-messagebox-group:last-child{border-bottom:thin none transparent}

/* cache key: wikidb:resourceloader:filter:minify-css:4:8b08bdc91c52a9ffba396dccfb5b473c */
</style><meta name="ResourceLoaderDynamicStyles" content="">
<link rel="stylesheet" href="8259%20PIC%20-%20OSDev%20Wiki_files/load_002.css">
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: wikidb:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */
</style>
<script src="8259%20PIC%20-%20OSDev%20Wiki_files/load_004.php"></script><script src="8259%20PIC%20-%20OSDev%20Wiki_files/load_003.php"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "8259_PIC", "wgTitle": "8259 PIC", "wgCurRevisionId": 19781, "wgArticleId": 1478, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["Interrupts"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": []});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script><script type="text/javascript" src="8259%20PIC%20-%20OSDev%20Wiki_files/load.php"></script>
<style type="text/css">/*<![CDATA[*/
.source-c {line-height: normal;}
.source-c li, .source-c pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for c
 * CSS class: source-c, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.c.source-c .de1, .c.source-c .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.c.source-c  {font-family:monospace;}
.c.source-c .imp {font-weight: bold; color: red;}
.c.source-c li, .c.source-c .li1 {font-weight: normal; vertical-align:top;}
.c.source-c .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.c.source-c .li2 {font-weight: bold; vertical-align:top;}
.c.source-c .kw1 {color: #b1b100;}
.c.source-c .kw2 {color: #000000; font-weight: bold;}
.c.source-c .kw3 {color: #000066;}
.c.source-c .kw4 {color: #993333;}
.c.source-c .co1 {color: #666666; font-style: italic;}
.c.source-c .co2 {color: #339933;}
.c.source-c .coMULTI {color: #808080; font-style: italic;}
.c.source-c .es0 {color: #000099; font-weight: bold;}
.c.source-c .es1 {color: #000099; font-weight: bold;}
.c.source-c .es2 {color: #660099; font-weight: bold;}
.c.source-c .es3 {color: #660099; font-weight: bold;}
.c.source-c .es4 {color: #660099; font-weight: bold;}
.c.source-c .es5 {color: #006699; font-weight: bold;}
.c.source-c .br0 {color: #009900;}
.c.source-c .sy0 {color: #339933;}
.c.source-c .st0 {color: #ff0000;}
.c.source-c .nu0 {color: #0000dd;}
.c.source-c .nu6 {color: #208080;}
.c.source-c .nu8 {color: #208080;}
.c.source-c .nu12 {color: #208080;}
.c.source-c .nu16 {color:#800080;}
.c.source-c .nu17 {color:#800080;}
.c.source-c .nu18 {color:#800080;}
.c.source-c .nu19 {color:#800080;}
.c.source-c .me1 {color: #202020;}
.c.source-c .me2 {color: #202020;}
.c.source-c .ln-xtra, .c.source-c li.ln-xtra, .c.source-c div.ln-xtra {background-color: #ffc;}
.c.source-c span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style><style type="text/css">/*<![CDATA[*/
.source-asm {line-height: normal;}
.source-asm li, .source-asm pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for asm
 * CSS class: source-asm, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.asm.source-asm .de1, .asm.source-asm .de2 {font: normal normal 1em/1.2em monospace; margin:0; padding:0; background:none; vertical-align:top;}
.asm.source-asm  {font-family:monospace;}
.asm.source-asm .imp {font-weight: bold; color: red;}
.asm.source-asm li, .asm.source-asm .li1 {font-weight: normal; vertical-align:top;}
.asm.source-asm .ln {width:1px;text-align:right;margin:0;padding:0 2px;vertical-align:top;}
.asm.source-asm .li2 {font-weight: bold; vertical-align:top;}
.asm.source-asm .kw1 {color: #00007f; font-weight: bold;}
.asm.source-asm .kw2 {color: #0000ff; font-weight: bold;}
.asm.source-asm .kw3 {color: #00007f;}
.asm.source-asm .kw4 {color: #000000; font-weight: bold;}
.asm.source-asm .kw5 {color: #000000; font-weight: bold;}
.asm.source-asm .co1 {color: #666666; font-style: italic;}
.asm.source-asm .co2 {color: #adadad; font-style: italic;}
.asm.source-asm .es0 {color: #000099; font-weight: bold;}
.asm.source-asm .br0 {color: #009900; font-weight: bold;}
.asm.source-asm .sy0 {color: #339933;}
.asm.source-asm .st0 {color: #7f007f;}
.asm.source-asm .nu0 {color: #0000ff;}
.asm.source-asm .ln-xtra, .asm.source-asm li.ln-xtra, .asm.source-asm div.ln-xtra {background-color: #ffc;}
.asm.source-asm span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style><!--[if lt IE 7]><style type="text/css">body{behavior:url("/skins/vector/csshover.min.htc")}</style><![endif]--></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-8259_PIC action-view skin-vector">
		<div id="mw-page-base" class="noprint"></div>
		<div id="mw-head-base" class="noprint"></div>
		<!-- content -->
		<div id="content">
			<a id="top"></a>
			<div id="mw-js-message" style="display:none;" class="js-messagebox"></div>
						<!-- firstHeading -->
			<h1 id="firstHeading" class="firstHeading">8259 PIC</h1>
			<!-- /firstHeading -->
			<!-- bodyContent -->
			<div id="bodyContent">
								<!-- tagline -->
				<div id="siteSub">From OSDev Wiki</div>
				<!-- /tagline -->
								<!-- subtitle -->
				<div id="contentSub"></div>
				<!-- /subtitle -->
																<!-- jumpto -->
				<div id="jump-to-nav">
					Jump to: <a href="#mw-head">navigation</a>,
					<a href="#p-search">search</a>
				</div>
				<!-- /jumpto -->
								<!-- bodycontent -->
				<div dir="ltr" class="mw-content-ltr" lang="en"><p>The 8259 <i>Programmable Interrupt Controller</i>
 (PIC) is one of the most important chips making up the x86 
architecture. Without it, the x86 architecture would not be an interrupt
 driven architecture. The function of the 8259A is to manage hardware 
interrupts and send them to the appropriate system <a href="http://wiki.osdev.org/Interrupts" title="Interrupts">interrupt</a>. This allows the system to respond to devices needs without loss of time (from polling the device, for instance).
</p><p>It is important to note that <a href="http://wiki.osdev.org/APIC" title="APIC">APIC</a> has replaced the 8259 PIC in more modern systems, especially those with multiple cores/processors.
</p>
<table id="toc" class="toc"><tbody><tr><td><div id="toctitle"><h2>Contents</h2><span class="toctoggle">&nbsp;[<a href="#" class="internal" id="togglelink">hide</a>]&nbsp;</span></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#What_does_the_8259_PIC_do.3F"><span class="tocnumber">1</span> <span class="toctext">What does the 8259 PIC do?</span></a>
<ul>
<li class="toclevel-2 tocsection-2"><a href="#The_IBM_PC_8259_PIC_Architecture"><span class="tocnumber">1.1</span> <span class="toctext">The IBM PC 8259 PIC Architecture</span></a></li>
<li class="toclevel-2 tocsection-3"><a href="#The_IBM_PC.2FAT_8259_PIC_Architecture"><span class="tocnumber">1.2</span> <span class="toctext">The IBM PC/AT 8259 PIC Architecture</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-4"><a href="#How_does_the_8259_PIC_chip_work.3F"><span class="tocnumber">2</span> <span class="toctext">How does the 8259 PIC chip work?</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#Programming_with_the_8259_PIC"><span class="tocnumber">3</span> <span class="toctext">Programming with the 8259 PIC</span></a>
<ul>
<li class="toclevel-2 tocsection-6"><a href="#Real_Mode"><span class="tocnumber">3.1</span> <span class="toctext">Real Mode</span></a></li>
<li class="toclevel-2 tocsection-7"><a href="#Protected_Mode"><span class="tocnumber">3.2</span> <span class="toctext">Protected Mode</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-8"><a href="#Code_Examples"><span class="tocnumber">4</span> <span class="toctext">Code Examples</span></a>
<ul>
<li class="toclevel-2 tocsection-9"><a href="#Common_Definitions"><span class="tocnumber">4.1</span> <span class="toctext">Common Definitions</span></a></li>
<li class="toclevel-2 tocsection-10"><a href="#End_of_Interrupt"><span class="tocnumber">4.2</span> <span class="toctext">End of Interrupt</span></a></li>
<li class="toclevel-2 tocsection-11"><a href="#Initialisation"><span class="tocnumber">4.3</span> <span class="toctext">Initialisation</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-12"><a href="#Disabling"><span class="tocnumber">5</span> <span class="toctext">Disabling</span></a></li>
<li class="toclevel-1 tocsection-13"><a href="#Masking"><span class="tocnumber">6</span> <span class="toctext">Masking</span></a></li>
<li class="toclevel-1 tocsection-14"><a href="#ISR_and_IRR"><span class="tocnumber">7</span> <span class="toctext">ISR and IRR</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#Spurious_IRQs"><span class="tocnumber">8</span> <span class="toctext">Spurious IRQs</span></a>
<ul>
<li class="toclevel-2 tocsection-16"><a href="#Handling_Spurious_IRQs"><span class="tocnumber">8.1</span> <span class="toctext">Handling Spurious IRQs</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-17"><a href="#See_Also"><span class="tocnumber">9</span> <span class="toctext">See Also</span></a>
<ul>
<li class="toclevel-2 tocsection-18"><a href="#Articles"><span class="tocnumber">9.1</span> <span class="toctext">Articles</span></a></li>
<li class="toclevel-2 tocsection-19"><a href="#Threads"><span class="tocnumber">9.2</span> <span class="toctext">Threads</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#External_Links"><span class="tocnumber">9.3</span> <span class="toctext">External Links</span></a></li>
</ul>
</li>
</ul>
</td></tr></tbody></table>
<h2> <span class="mw-headline" id="What_does_the_8259_PIC_do.3F">What does the 8259 PIC do?</span></h2>
<p>The 8259 PIC controls the CPU's interrupt mechanism, by accepting 
several interrupt requests and feeding them to the processor in order. 
For instance, when a keyboard registers a keyhit, it sends a pulse along
 its interrupt line (<a href="http://wiki.osdev.org/IRQ" title="IRQ" class="mw-redirect">IRQ</a>
 1) to the PIC chip, which then translates the IRQ into a system 
interrupt, and sends a message to interrupt the CPU from whatever it is 
doing. Part of the kernel's job is to either handle these IRQs and 
perform the necessary procedures (poll the keyboard for the scancode) or
 alert a userspace program to the interrupt (send a message to the 
keyboard driver).
</p><p>Without a PIC, you would have to poll all the devices in the 
system to see if they want to do anything (signal an event), but with a 
PIC, your system can run along nicely until such time that a device 
wants to signal an event, which means you don't waste time going to the 
devices, you let the devices come to you when they are ready.
</p>
<h3> <span class="mw-headline" id="The_IBM_PC_8259_PIC_Architecture">The IBM PC 8259 PIC Architecture</span></h3>
<p>In the beginning (IBM PC and XT), only a single 8259 PIC chip was 
used, which provided 8 IRQs to the system. These were traditionally 
mapped by the BIOS to interrupts 8 to 15 (0x08 to 0x0F). It is unlikely 
that any of these single-PIC machines will be encountered these days.
</p>
<h3> <span class="mw-headline" id="The_IBM_PC.2FAT_8259_PIC_Architecture">The IBM PC/AT 8259 PIC Architecture</span></h3>
<p>The IBM PC/AT extended the PC architecture by adding a second 8259 
PIC chip. This was possible due to the 8259A's ability to cascade 
interrupts, that is, have them flow through one chip and into another. 
This gives a total of 15 interrupts. Why 15 and not 16? That's because 
when you cascade chips, the PIC needs to use one of the interrupt lines 
to signal the other chip.
</p><p>Thus, in an AT, IRQ line 2 is used to signal the second chip... 
But to confuse things more, IRQ 9 is redirected to IRQ 2. So when you 
get an IRQ 9, the signal is redirected to IRQ 2. This two-chip 
architecture is still used and available in modern systems, and hasn't 
changed (except for the advent of the above-mentioned APIC 
architecture).
</p>
<h2> <span class="mw-headline" id="How_does_the_8259_PIC_chip_work.3F">How does the 8259 PIC chip work?</span></h2>
<p>Each of the two 8259 PICs in modern systems have 8 inputs. When any 
of the inputs is raised, the PIC sets a bit internally telling one of 
the inputs needs servicing. It then checks whether that channel is 
masked or not, and whether there's an interrupt already pending.
If the channel is unmasked and there's no interrupt pending, the PIC 
will raise the interrupt line. On the slave, this feeds IRQ 2 to the 
master, and the master is connected to the processor interrupt line.
</p><p>When the processor accepts the interrupt, the master checks which
 of the two PICs is responsible for answering, then either supplies the 
interrupt number to the processor, or asks the slave to do so. The PIC 
that answers looks up the "vector offset" variable stored internally and
 adds the input line to form the requested interrupt number. After that 
the processor will look up the interrupt address and act accordingly 
(see <a href="http://wiki.osdev.org/Interrupts" title="Interrupts">Interrupts</a> for more details).
</p>
<h2> <span class="mw-headline" id="Programming_with_the_8259_PIC">Programming with the 8259 PIC</span></h2>
<p>Each chip (master and slave) has a command port and a data port 
(given in the table below). When no command is issued, the data port 
allows us to access the interrupt mask of the 8259 PIC.
</p>
<table style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; {{{1}}}" border="2" cellspacing="0" cellpadding="4">

<tbody><tr>
<th> Chip - Purpose
</th>
<th> <a href="http://wiki.osdev.org/I/O_ports" title="I/O ports" class="mw-redirect">I/O port</a>
</th></tr>
<tr>
<td> Master PIC - Command
</td>
<td> 0x0020
</td></tr>
<tr>
<td> Master PIC - Data
</td>
<td> 0x0021
</td></tr>
<tr>
<td> Slave PIC - Command
</td>
<td> 0x00A0
</td></tr>
<tr>
<td> Slave PIC - Data
</td>
<td> 0x00A1
</td></tr></tbody></table>
<ul><li> Each PIC vector offset must be divisible by 8, as the 8259A 
uses the lower 3 bits for the interrupt number of a particular interrupt
 (0..7).
</li><li> The only way to change the vector offsets used by the 8259 PIC
 is to re-initialize it, which explains why the code is "so long" and 
plenty of things that have apparently no reasons to be here.
</li><li> If you plan to return to real mode from protected mode (for 
any purpose), you really must restore the PIC to its former 
configuration.
</li></ul>
<h3> <span class="mw-headline" id="Real_Mode">Real Mode</span></h3>
<table style="margin-top:1em; margin-bottom:1em; background:#f9f9f9; border:1px #aaa solid; border-collapse:collapse; {{{1}}}" border="2" cellspacing="0" cellpadding="4">

<tbody><tr>
<th> Chip
</th>
<th> Interrupt numbers (IRQ)
</th>
<th> Vector offset
</th>
<th> Interrupt Numbers
</th></tr>
<tr>
<td> Master PIC
</td>
<td> 0 to 7
</td>
<td> 0x08
</td>
<td> 0x08 to 0x0F
</td></tr>
<tr>
<td> Slave PIC
</td>
<td> 8 to 15
</td>
<td> 0x70
</td>
<td> 0x70 to 0x77
</td></tr></tbody></table>
<p>These default BIOS values suit real mode programming quite well; they
 do not conflict with any CPU exceptions like they do in protected mode.
</p>
<h3> <span class="mw-headline" id="Protected_Mode">Protected Mode</span></h3>
<p>In protected mode, the IRQs 0 to 7 conflict with the CPU exception 
which are reserved by Intel up until 0x1F. (It was an IBM design 
mistake.) Consequently it is difficult to tell the difference between an
 IRQ or an software error. It is thus recommended to change the PIC's 
offsets (also known as remapping the PIC) so that IRQs use non-reserved 
vectors. A common choice is to move them to the beginning of the 
available range (IRQs 0..0xF -&gt; INT 0x20..0x2F). For that, we need to
 set the master PIC's offset to 0x20 and the slave's to 0x28. For code 
examples, see below.
</p>
<h2> <span class="mw-headline" id="Code_Examples">Code Examples</span></h2>
<h3> <span class="mw-headline" id="Common_Definitions">Common Definitions</span></h3>
<p>This is just a set of definitions common to the rest of this section. For the outb(), inb() and io_wait() functions, see <a href="http://wiki.osdev.org/Inline_Assembly/Examples#I.2FO_access" title="Inline Assembly/Examples">this page</a>.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="co2">#define PIC1		0x20		/* IO base address for master PIC */</span>
<span class="co2">#define PIC2		0xA0		/* IO base address for slave PIC */</span>
<span class="co2">#define PIC1_COMMAND	PIC1</span>
<span class="co2">#define PIC1_DATA	(PIC1+1)</span>
<span class="co2">#define PIC2_COMMAND	PIC2</span>
<span class="co2">#define PIC2_DATA	(PIC2+1)</span></pre></div></div>
<h3> <span class="mw-headline" id="End_of_Interrupt">End of Interrupt</span></h3>
<p>Perhaps the most common command issued to the PIC chips is the <i>end of interrupt</i>
 (EOI) command (code 0x20). This is issued to the PIC chips at the end 
of an IRQ-based interrupt routine. If the IRQ came from the Master PIC, 
it is sufficient to issue this command only to the Master PIC; however 
if the IRQ came from the Slave PIC, it is necessary to issue the command
 to both PIC chips.
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="co2">#define PIC_EOI		0x20		/* End-of-interrupt command code */</span>
&nbsp;
<span class="kw4">void</span> PIC_sendEOI<span class="br0">(</span><span class="kw4">unsigned</span> <span class="kw4">char</span> irq<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw1">if</span><span class="br0">(</span>irq <span class="sy0">&gt;=</span> <span class="nu0">8</span><span class="br0">)</span>
		outb<span class="br0">(</span>PIC2_COMMAND<span class="sy0">,</span>PIC_EOI<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	outb<span class="br0">(</span>PIC1_COMMAND<span class="sy0">,</span>PIC_EOI<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<h3> <span class="mw-headline" id="Initialisation">Initialisation</span></h3>
<p>When you enter protected mode (or even before hand, if you're not using <a href="http://wiki.osdev.org/GRUB" title="GRUB">GRUB</a>)
 the first command you will need to give the two PICs is the initialise 
command (code 0x11). This command makes the PIC wait for 3 extra 
"initialisation words" on the data port. These bytes give the PIC:
</p>
<ul><li> Its vector offset. (ICW2)
</li><li> Tell it how it is wired to master/slaves. (ICW3)
</li><li> Gives additional information about the environment. (ICW4)
</li></ul>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="coMULTI">/* reinitialize the PIC controllers, giving them specified vector offsets
   rather than 8h and 70h, as configured by default */</span>
&nbsp;
<span class="co2">#define ICW1_ICW4	0x01		/* ICW4 (not) needed */</span>
<span class="co2">#define ICW1_SINGLE	0x02		/* Single (cascade) mode */</span>
<span class="co2">#define ICW1_INTERVAL4	0x04		/* Call address interval 4 (8) */</span>
<span class="co2">#define ICW1_LEVEL	0x08		/* Level triggered (edge) mode */</span>
<span class="co2">#define ICW1_INIT	0x10		/* Initialization - required! */</span>
&nbsp;
<span class="co2">#define ICW4_8086	0x01		/* 8086/88 (MCS-80/85) mode */</span>
<span class="co2">#define ICW4_AUTO	0x02		/* Auto (normal) EOI */</span>
<span class="co2">#define ICW4_BUF_SLAVE	0x08		/* Buffered mode/slave */</span>
<span class="co2">#define ICW4_BUF_MASTER	0x0C		/* Buffered mode/master */</span>
<span class="co2">#define ICW4_SFNM	0x10		/* Special fully nested (not) */</span>
&nbsp;
<span class="coMULTI">/*
arguments:
	offset1 - vector offset for master PIC
		vectors on the master become offset1..offset1+7
	offset2 - same for slave PIC: offset2..offset2+7
*/</span>
<span class="kw4">void</span> PIC_remap<span class="br0">(</span><span class="kw4">int</span> offset1<span class="sy0">,</span> <span class="kw4">int</span> offset2<span class="br0">)</span>
<span class="br0">{</span>
	<span class="kw4">unsigned</span> <span class="kw4">char</span> a1<span class="sy0">,</span> a2<span class="sy0">;</span>
&nbsp;
	a1 <span class="sy0">=</span> inb<span class="br0">(</span>PIC1_DATA<span class="br0">)</span><span class="sy0">;</span>                        <span class="co1">// save masks</span>
	a2 <span class="sy0">=</span> inb<span class="br0">(</span>PIC2_DATA<span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	outb<span class="br0">(</span>PIC1_COMMAND<span class="sy0">,</span> ICW1_INIT<span class="sy0">+</span>ICW1_ICW4<span class="br0">)</span><span class="sy0">;</span>  <span class="co1">// starts the initialization sequence (in cascade mode)</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
	outb<span class="br0">(</span>PIC2_COMMAND<span class="sy0">,</span> ICW1_INIT<span class="sy0">+</span>ICW1_ICW4<span class="br0">)</span><span class="sy0">;</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
	outb<span class="br0">(</span>PIC1_DATA<span class="sy0">,</span> offset1<span class="br0">)</span><span class="sy0">;</span>                 <span class="co1">// ICW2: Master PIC vector offset</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
	outb<span class="br0">(</span>PIC2_DATA<span class="sy0">,</span> offset2<span class="br0">)</span><span class="sy0">;</span>                 <span class="co1">// ICW2: Slave PIC vector offset</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
	outb<span class="br0">(</span>PIC1_DATA<span class="sy0">,</span> <span class="nu0">4</span><span class="br0">)</span><span class="sy0">;</span>                       <span class="co1">// ICW3: tell Master PIC that there is a slave PIC at IRQ2 (0000 0100)</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
	outb<span class="br0">(</span>PIC2_DATA<span class="sy0">,</span> <span class="nu0">2</span><span class="br0">)</span><span class="sy0">;</span>                       <span class="co1">// ICW3: tell Slave PIC its cascade identity (0000 0010)</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	outb<span class="br0">(</span>PIC1_DATA<span class="sy0">,</span> ICW4_8086<span class="br0">)</span><span class="sy0">;</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
	outb<span class="br0">(</span>PIC2_DATA<span class="sy0">,</span> ICW4_8086<span class="br0">)</span><span class="sy0">;</span>
	io_wait<span class="br0">(</span><span class="br0">)</span><span class="sy0">;</span>
&nbsp;
	outb<span class="br0">(</span>PIC1_DATA<span class="sy0">,</span> a1<span class="br0">)</span><span class="sy0">;</span>   <span class="co1">// restore saved masks.</span>
	outb<span class="br0">(</span>PIC2_DATA<span class="sy0">,</span> a2<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p><i>Note the presence of io_wait() calls, on older machines its 
necessary to give the PIC some time to react to commands as they might 
not be processed quickly</i>
</p>
<h2> <span class="mw-headline" id="Disabling"> Disabling </span></h2>
<p>If you are going to use the processor local APIC and the IOAPIC, you must first disable the PIC.  This is done via:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="asm source-asm"><pre class="de1"><span class="kw1">mov</span> <span class="kw3">al</span><span class="sy0">,</span> <span class="nu0">0xff</span>
<span class="kw1">out</span> <span class="nu0">0xa1</span><span class="sy0">,</span> <span class="kw3">al</span>
<span class="kw1">out</span> <span class="nu0">0x21</span><span class="sy0">,</span> <span class="kw3">al</span></pre></div></div>
<h2> <span class="mw-headline" id="Masking"> Masking </span></h2>
<p>The PIC has an internal register called the IMR, or the Interrupt 
Mask Register. It is 8 bits wide. This register is a bitmap of the 
request lines going into the PIC. When a bit is set, the PIC ignores the
 request and continues normal operation. Note that setting the mask on a
 higher request line will not affect a lower line. Masking IRQ2 will 
cause the Slave PIC to stop raising IRQs.
</p><p>Here is an example of how to mask an IRQ:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="kw4">void</span> IRQ_set_mask<span class="br0">(</span><span class="kw4">unsigned</span> <span class="kw4">char</span> IRQline<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">uint16_t</span> port<span class="sy0">;</span>
    <span class="kw4">uint8_t</span> value<span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span><span class="br0">(</span>IRQline <span class="sy0">&lt;</span> <span class="nu0">8</span><span class="br0">)</span> <span class="br0">{</span>
        port <span class="sy0">=</span> PIC1_DATA<span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
        port <span class="sy0">=</span> PIC2_DATA<span class="sy0">;</span>
        IRQline <span class="sy0">-=</span> <span class="nu0">8</span><span class="sy0">;</span>
    <span class="br0">}</span>
    value <span class="sy0">=</span> inb<span class="br0">(</span>port<span class="br0">)</span> <span class="sy0">|</span> <span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> IRQline<span class="br0">)</span><span class="sy0">;</span>
    outb<span class="br0">(</span>port<span class="sy0">,</span> value<span class="br0">)</span><span class="sy0">;</span>        
<span class="br0">}</span>
&nbsp;
<span class="kw4">void</span> IRQ_clear_mask<span class="br0">(</span><span class="kw4">unsigned</span> <span class="kw4">char</span> IRQline<span class="br0">)</span> <span class="br0">{</span>
    <span class="kw4">uint16_t</span> port<span class="sy0">;</span>
    <span class="kw4">uint8_t</span> value<span class="sy0">;</span>
&nbsp;
    <span class="kw1">if</span><span class="br0">(</span>IRQline <span class="sy0">&lt;</span> <span class="nu0">8</span><span class="br0">)</span> <span class="br0">{</span>
        port <span class="sy0">=</span> PIC1_DATA<span class="sy0">;</span>
    <span class="br0">}</span> <span class="kw1">else</span> <span class="br0">{</span>
        port <span class="sy0">=</span> PIC2_DATA<span class="sy0">;</span>
        IRQline <span class="sy0">-=</span> <span class="nu0">8</span><span class="sy0">;</span>
    <span class="br0">}</span>
    value <span class="sy0">=</span> inb<span class="br0">(</span>port<span class="br0">)</span> <span class="sy0">&amp;</span> ~<span class="br0">(</span><span class="nu0">1</span> <span class="sy0">&lt;&lt;</span> IRQline<span class="br0">)</span><span class="sy0">;</span>
    outb<span class="br0">(</span>port<span class="sy0">,</span> value<span class="br0">)</span><span class="sy0">;</span>        
<span class="br0">}</span></pre></div></div>
<h2> <span class="mw-headline" id="ISR_and_IRR">ISR and IRR</span></h2>
<p>The PIC chip has two interrupt status registers: the In-Service 
Register (ISR) and the Interrupt Request Register (IRR).  The ISR tells 
us which interrupts are being serviced, meaning IRQs sent to the CPU.  
The IRR tells us which interrupts have been raised.  Based on the 
interrupt mask (IMR), the PIC will send interrupts from the IRR to the 
CPU, at which point they are marked in the ISR.
</p><p>The ISR and IRR can be read via the OCW3 command word.  This is a
 command sent to one of the command ports (0x20 or 0xa0) with bit 3 set.
  To read the ISR or IRR, write the appropriate command to the command 
port, and then read the command port (not the data port).  To read the 
IRR, write 0x0a.  To read the ISR, write 0x0b.  
</p><p>The ISR and IRR are each 8 bits.  Here is an example of how to read 16 bits worth of ISR and IRR data from two cascaded PICs:
</p>
<div dir="ltr" class="mw-geshi" style="text-align: left;"><div class="c source-c"><pre class="de1"><span class="co2">#define PIC1_CMD                    0x20</span>
<span class="co2">#define PIC1_DATA                   0x21</span>
<span class="co2">#define PIC2_CMD                    0xA0</span>
<span class="co2">#define PIC2_DATA                   0xA1</span>
<span class="co2">#define PIC_READ_IRR                0x0a    /* OCW3 irq ready next CMD read */</span>
<span class="co2">#define PIC_READ_ISR                0x0b    /* OCW3 irq service next CMD read */</span>
&nbsp;
<span class="coMULTI">/* Helper func */</span>
<span class="kw4">static</span> <span class="kw4">uint16_t</span> __pic_get_irq_reg<span class="br0">(</span><span class="kw4">int</span> ocw3<span class="br0">)</span>
<span class="br0">{</span>
    <span class="coMULTI">/* OCW3 to PIC CMD to get the register values.  PIC2 is chained, and
     * represents IRQs 8-15.  PIC1 is IRQs 0-7, with 2 being the chain */</span>
    outb<span class="br0">(</span>PIC1_CMD<span class="sy0">,</span> ocw3<span class="br0">)</span><span class="sy0">;</span>
    outb<span class="br0">(</span>PIC2_CMD<span class="sy0">,</span> ocw3<span class="br0">)</span><span class="sy0">;</span>
    <span class="kw1">return</span> <span class="br0">(</span>inb<span class="br0">(</span>PIC2_CMD<span class="br0">)</span> <span class="sy0">&lt;&lt;</span> <span class="nu0">8</span><span class="br0">)</span> <span class="sy0">|</span> inb<span class="br0">(</span>PIC1_CMD<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="coMULTI">/* Returns the combined value of the cascaded PICs irq request register */</span>
<span class="kw4">uint16_t</span> pic_get_irr<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> __pic_get_irq_reg<span class="br0">(</span>PIC_READ_IRR<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span>
&nbsp;
<span class="coMULTI">/* Returns the combined value of the cascaded PICs in-service register */</span>
<span class="kw4">uint16_t</span> pic_get_isr<span class="br0">(</span><span class="kw4">void</span><span class="br0">)</span>
<span class="br0">{</span>
    <span class="kw1">return</span> __pic_get_irq_reg<span class="br0">(</span>PIC_READ_ISR<span class="br0">)</span><span class="sy0">;</span>
<span class="br0">}</span></pre></div></div>
<p>Note that these functions will show bit 2 (0x0004) as on whenever any
 of the PIC2 bits are set, due to the chained nature of the PICs.  Also 
note that it is not necessary to reset the OCW3 command every time you 
want to read.  Once you set it for either the IRR or the ISR, future 
reads of the CMD port will return the appropriate register.  The chip 
remembers what OCW3 setting you used.  (Disclaimer: I have not tested 
this last part, but that's what the spec says.)
</p>
<h2> <span class="mw-headline" id="Spurious_IRQs">Spurious IRQs</span></h2>
<p>When an IRQ occurs, the PIC chip tells the CPU (via. the PIC's INTR 
line) that there's an interrupt, and the CPU acknowledges this and waits
 for the PIC to send the interrupt vector. This creates a race 
condition: if the IRQ disappears after the PIC has told the CPU there's 
an interrupt but before the PIC has sent the interrupt vector to the 
CPU, then the CPU will be waiting for the PIC to tell it which interrupt
 vector but the PIC won't have a valid interrupt vector to tell the CPU.
</p><p>To get around this, the PIC tells the CPU a fake interrupt 
number. This is a spurious IRQ. The fake interrupt number is the lowest 
priority interrupt number for the corresponding PIC chip (IRQ 7 for the 
master PIC, and IRQ 15 for the slave PIC).
</p><p>There are several reasons for the interrupt to disappear. In my 
experience the most common reason is software sending an EOI at the 
wrong time. Other reasons include noise on IRQ lines (or the INTR line).
</p>
<h3> <span class="mw-headline" id="Handling_Spurious_IRQs">Handling Spurious IRQs</span></h3>
<p>For a spurious IRQ, there is no real IRQ and the PIC chip's ISR (In 
Service Register) flag for the corresponding IRQ will not be set. This 
means that the interrupt handler must not send an EOI back to the PIC to
 reset the ISR flag.
</p><p>The correct way to handle an IRQ 7 is to first check the master 
PIC chip's ISR to see if the IRQ is a spurious IRQ or a real IRQ. If it 
is a real IRQ then it is treated the same as any other real IRQ. If it 
is a spurious IRQ then you ignore it (and do not send the EOI).
</p><p>The correct way to handle an IRQ 15 is similar, but a little 
trickier due to the interaction between the slave PIC and the master 
PIC. First check the slave PIC chip's ISR to see if the IRQ is a 
spurious IRQ or a real IRQ. If it is a real IRQ then it is treated the 
same as any other real IRQ. If it's a spurious IRQ then don't send the 
EOI to the slave PIC; however you will still need to send the EOI to the
 master PIC because the master PIC itself won't know that it was a 
spurious IRQ from the slave.
</p><p>Also note that some operating systems (e.g. Linux) keep track of 
the number of spurious IRQs that have occurred (e.g. by incrementing a 
counter when a spurious IRQ occurs). This can be useful for detecting 
problems in software (e.g. sending EOIs at the wrong time) and detecting
 problems in hardware (e.g. line noise).
</p><p><br>
</p>
<h2> <span class="mw-headline" id="See_Also"> See Also </span></h2>
<h3> <span class="mw-headline" id="Articles"> Articles </span></h3>
<ul><li> <a href="http://wiki.osdev.org/APIC" title="APIC">APIC</a>
</li><li> <a href="http://wiki.osdev.org/IOAPIC" title="IOAPIC">IOAPIC</a>
</li></ul>
<h3> <span class="mw-headline" id="Threads"> Threads </span></h3>
<h3> <span class="mw-headline" id="External_Links"> External Links </span></h3>
<ul><li> <a rel="nofollow" class="external text" href="http://pdos.csail.mit.edu/6.828/2005/readings/hardware/8259A.pdf">Intel Datasheet</a>
</li></ul>

<!-- 
NewPP limit report
Preprocessor node count: 180/1000000
Post-expand include size: 324/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key wikidb:pcache:idhash:1478-0!*!0!!en!*!* and timestamp 20170316064339 -->
</div>				<!-- /bodycontent -->
								<!-- printfooter -->
				<div class="printfooter">
				Retrieved from "<a href="http://wiki.osdev.org/index.php?title=8259_PIC&amp;oldid=19781">http://wiki.osdev.org/index.php?title=8259_PIC&amp;oldid=19781</a>"				</div>
				<!-- /printfooter -->
												<!-- catlinks -->
				<div id="catlinks" class="catlinks"><div id="mw-normal-catlinks"><a href="http://wiki.osdev.org/Special:Categories" title="Special:Categories">Category</a>: <ul><li><a href="http://wiki.osdev.org/Category:Interrupts" title="Category:Interrupts">Interrupts</a></li></ul></div></div>				<!-- /catlinks -->
												<div class="visualClear"></div>
				<!-- debughtml -->
								<!-- /debughtml -->
			</div>
			<!-- /bodyContent -->
		</div>
		<!-- /content -->
		<!-- header -->
		<div id="mw-head" class="noprint">
			
<!-- 0 -->
<div id="p-personal" class="">
	<h5>Personal tools</h5>
	<ul>
		<li id="pt-login"><a href="http://wiki.osdev.org/index.php?title=Special:UserLogin&amp;returnto=8259_PIC" title="You are encouraged to log in; however, it is not mandatory [alt-shift-o]" accesskey="o">Log in</a></li>
	</ul>
</div>

<!-- /0 -->
			<div id="left-navigation">
				
<!-- 0 -->
<div id="p-namespaces" class="vectorTabs">
	<h5>Namespaces</h5>
	<ul>
					<li id="ca-nstab-main" class="selected"><span><a href="http://wiki.osdev.org/8259_PIC" title="View the content page [alt-shift-c]" accesskey="c">Page</a></span></li>
					<li id="ca-talk"><span><a href="http://wiki.osdev.org/Talk:8259_PIC" title="Discussion about the content page [alt-shift-t]" accesskey="t">Discussion</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-variants" class="vectorMenu emptyPortlet">
		<h5><span>Variants</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->
			</div>
			<div id="right-navigation">
				
<!-- 0 -->
<div id="p-views" class="vectorTabs">
	<h5>Views</h5>
	<ul>
					<li id="ca-view" class="selected"><span><a href="http://wiki.osdev.org/8259_PIC">Read</a></span></li>
					<li id="ca-viewsource"><span><a href="http://wiki.osdev.org/index.php?title=8259_PIC&amp;action=edit" title="This page is protected.
You can view its source [alt-shift-e]" accesskey="e">View source</a></span></li>
					<li id="ca-history" class="collapsible"><span><a href="http://wiki.osdev.org/index.php?title=8259_PIC&amp;action=history" title="Past revisions of this page [alt-shift-h]" accesskey="h">View history</a></span></li>
			</ul>
</div>

<!-- /0 -->

<!-- 1 -->
<div id="p-cactions" class="vectorMenu emptyPortlet">
	<h5><span>Actions</span><a href="#"></a></h5>
	<div class="menu">
		<ul>
					</ul>
	</div>
</div>

<!-- /1 -->

<!-- 2 -->
<div id="p-search">
	<h5><label for="searchInput">Search</label></h5>
	<form action="/index.php" id="searchform">
		<input name="title" value="Special:Search" type="hidden">
				<input name="search" title="Search OSDev Wiki [alt-shift-f]" accesskey="f" id="searchInput" type="search">		<input name="go" value="Go" title="Go to a page with this exact name if exists" id="searchGoButton" class="searchButton" type="submit">		<input name="fulltext" value="Search" title="Search the pages for this text" id="mw-searchButton" class="searchButton" type="submit">			</form>
</div>

<!-- /2 -->
			</div>
		</div>
		<!-- /header -->
		<!-- panel -->
			<div id="mw-panel" class="noprint">
				<!-- logo -->
					<div id="p-logo"><a style="background-image: url(/skins/common/images/osdev.png);" href="http://wiki.osdev.org/Main_Page" title="Visit the main page"></a></div>
				<!-- /logo -->
				
<!-- navigation -->
<div class="portal" id="p-navigation">
	<h5>Navigation</h5>
	<div class="body">
		<ul>
			<li id="n-mainpage"><a href="http://wiki.osdev.org/Main_Page" title="Visit the main page [alt-shift-z]" accesskey="z">Main Page</a></li>
			<li id="n-portal"><a href="http://forum.osdev.org/" rel="nofollow" title="About the project, what you can do, where to find things">Forums</a></li>
			<li id="n-FAQ"><a href="http://wiki.osdev.org/Category:FAQ">FAQ</a></li>
			<li id="n-OS-Projects"><a href="http://wiki.osdev.org/Projects">OS Projects</a></li>
			<li id="n-randompage"><a href="http://wiki.osdev.org/Special:Random" title="Load a random page [alt-shift-x]" accesskey="x">Random page</a></li>
		</ul>
	</div>
</div>

<!-- /navigation -->

<!-- about -->
<div class="portal" id="p-about">
	<h5>About</h5>
	<div class="body">
		<ul>
			<li id="n-This-site"><a href="http://wiki.osdev.org/OSDevWiki:About">This site</a></li>
			<li id="n-Joining"><a href="http://wiki.osdev.org/OSDevWiki:Joining">Joining</a></li>
			<li id="n-Editing-help"><a href="http://wiki.osdev.org/OSDevWiki:Editing">Editing help</a></li>
			<li id="n-recentchanges"><a href="http://wiki.osdev.org/Special:RecentChanges" title="A list of recent changes in the wiki [alt-shift-r]" accesskey="r">Recent changes</a></li>
		</ul>
	</div>
</div>

<!-- /about -->

<!-- SEARCH -->

<!-- /SEARCH -->

<!-- TOOLBOX -->
<div class="portal" id="p-tb">
	<h5>Toolbox</h5>
	<div class="body">
		<ul>
			<li id="t-whatlinkshere"><a href="http://wiki.osdev.org/Special:WhatLinksHere/8259_PIC" title="A list of all wiki pages that link here [alt-shift-j]" accesskey="j">What links here</a></li>
			<li id="t-recentchangeslinked"><a href="http://wiki.osdev.org/Special:RecentChangesLinked/8259_PIC" title="Recent changes in pages linked from this page [alt-shift-k]" accesskey="k">Related changes</a></li>
			<li id="t-specialpages"><a href="http://wiki.osdev.org/Special:SpecialPages" title="A list of all special pages [alt-shift-q]" accesskey="q">Special pages</a></li>
			<li><a href="http://wiki.osdev.org/index.php?title=8259_PIC&amp;printable=yes" rel="alternate">Printable version</a></li>
			<li id="t-permalink"><a href="http://wiki.osdev.org/index.php?title=8259_PIC&amp;oldid=19781" title="Permanent link to this revision of the page">Permanent link</a></li>
		</ul>
	</div>
</div>

<!-- /TOOLBOX -->

<!-- LANGUAGES -->
<div class="portal" id="p-lang">
	<h5>In other languages</h5>
	<div class="body">
		<ul>
			<li class="interwiki-de"><a href="http://www.lowlevel.eu/wiki/Programmable_Interrupt_Controller" title="Programmable Interrupt Controller">Deutsch</a></li>
		</ul>
	</div>
</div>

<!-- /LANGUAGES -->
			</div>
		<!-- /panel -->
		<!-- footer -->
		<div id="footer">
							<ul id="footer-info">
											<li id="footer-info-lastmod"> This page was last modified on 5 September 2016, at 09:05.</li>
											<li id="footer-info-viewcount">This page has been accessed 145,232 times.</li>
									</ul>
							<ul id="footer-places">
											<li id="footer-places-privacy"><a href="http://wiki.osdev.org/OSDev_Wiki:Privacy_policy" title="OSDev Wiki:Privacy policy">Privacy policy</a></li>
											<li id="footer-places-about"><a href="http://wiki.osdev.org/OSDev_Wiki:About" title="OSDev Wiki:About">About OSDev Wiki</a></li>
											<li id="footer-places-disclaimer"><a href="http://wiki.osdev.org/OSDev_Wiki:General_disclaimer" title="OSDev Wiki:General disclaimer">Disclaimers</a></li>
									</ul>
										<ul id="footer-icons" class="noprint">
					<li id="footer-poweredbyico">
						<a href="http://www.mediawiki.org/"><img src="8259%20PIC%20-%20OSDev%20Wiki_files/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31"></a>
					</li>
				</ul>
						<div style="clear:both"></div>
		</div>
		<!-- /footer -->
		<!-- fixalpha -->
		<script type="text/javascript"> if ( window.isMSIE55 ) fixalpha(); </script>
		<!-- /fixalpha -->
		<script src="8259%20PIC%20-%20OSDev%20Wiki_files/load_006.php"></script>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", 
"mediawiki.page.ready", "mediawiki.legacy.wikibits", 
"mediawiki.legacy.ajax"]);
}
</script><script type="text/javascript" src="8259%20PIC%20-%20OSDev%20Wiki_files/load_005.php"></script>
<script src="8259%20PIC%20-%20OSDev%20Wiki_files/load_002.php"></script>
<script>if(window.mw){
	
mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"vector","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,

	
"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"en","language":"en","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});

	
	/* cache key: 
wikidb:resourceloader:filter:minify-js:4:19a4b18a9ac79a6b8c60b24af4668814
 */
}
</script><!-- Served in 0.046 secs. -->
	

</body></html>